# Simulations and logging

A model defines a function
\begin{linenomath}
\begin{equation}
\dot{y}\left(t\right)=f\left(y\left(t\right),u\left(t\right),t|p\right)
\end{equation}
\end{linenomath}
Here $y$ is the system state, $\dot{y}$ contains the state derivatives
and $t$ is the time variable. External inputs to the system are given
as $u\left(t\right)$. Common entries in $u$ are a dimensionless
pacing variable and a diffusion current from neighbouring cells. Parameters,
physical constants and other time-invariant values are lumped together
in $p$. During the course of a simulation these values will not change,
so for the rest of this document we'll simply write
\begin{linenomath}
\begin{equation}
\dot{y}=f\left(y,u,t\right)
\end{equation}
\end{linenomath}
For a typical cell model, $f$ is calculated in two parts:
\begin{linenomath}
\begin{eqnarray}
i & = & f_{1}\left(y,u,t\right)\\
\dot{y} & = & f_{2}\left(i\left(y,u,t\right),y,u,t\right)\\
 & = & f_{2}\left(f_{1}\left(y,u,t\right),y,u,t\right)=f\left(y,u,t\right)
\end{eqnarray}
\end{linenomath}
Where $i\left(y\left(t\right),u\left(t\right),t\right)$ are termed
the \emph{intermediary variables} of the system at time $t$. Models
do not explicitly define $f_{1}$ and $f_{2}$, but for the sake of
representation we assume that the model equations can be split up
into these two functions such that: (1) All interesting intermediary
variables (i.e. the currents) are calculated by $f_{1}$. (2) All
derivatives are calculated by $f_{2}$. (3) The original function
$f$ can be calculated as $f_{2}\left(f_{1},y,u,t\right)$. A more
general, programming-oriented way of looking at is is thinking of
$i$ as a \emph{by-product} of calling the right-hand side function
$f$.


## Logging options

At any time $t$, for a known set of parameters $p$, a full and minimal
description of the system can be given as:
\begin{linenomath}
\begin{equation}
\left\langle y\left(t\right),u\left(t\right),t\right\rangle
\end{equation}
\end{linenomath}
Any simulation method must be capable of logging these values at any
visited time $t$. We'll call logging these 3 \emph{basic logging}.
In addition, methods may choose to offer logging of intermediary variables
and/or derivatives.


## Order of operations

In the ideal case, at the start of a simulation:
\begin{linenomath}
\begin{eqnarray}
t & = & t_{min}\\
u & = & u\left(t_{min}\right)\\
y & = & y\left(t_{min}\right)=y_{0}
\end{eqnarray}
\end{linenomath}
and nothing else is known. If only basic logging is provided, a log
entry for $t_{min}$ can be written at this time. During a simulation,
at each step we do three things:
\begin{enumerate}
\item Call the rhs, thereby obtaining
\begin{linenomath}
\begin{eqnarray*}
i & = & i\left(t\right)\\
\dot{y} & = & \dot{y}\left(t\right)
\end{eqnarray*}
\end{linenomath}

\item If a log entry should be made at time $t$, now is the time to do
it
\item Perform the update:

\begin{enumerate}
\item Calculate $\Delta t$
\item Calculate $y\left(t+\Delta t\right)$
\item Calculate $u\left(t+\Delta t\right)$
\item Update the time to $t+\Delta t$
\end{enumerate}
\end{enumerate}

## CVODE Simulation

In the CVODE based simulation (and any other advanced solver), there
is no control over the points $\left\langle y\left(t\right),t\right\rangle $
at which the solver evaluates $f$ when moving to the next position.
This has two consequences:

### External inputs are not re-calculated

When CVODE explores the state space around $\left\langle y\left(t\right),u\left(t\right),t\right\rangle $, it can vary $t$ and $y\left(t\right)$ but $u\left(t\right)$ stays fixed.
This is a result of how Myokit calculates these external functions.
However, this is acceptable for the following reasons:
(1) The main entry in $u$ is the discontinuous pacing current (diffusion is not supported in cvode simulations).
Whenever the pacing changes, the solver is reset to the exact time of the change and re-initialised in the new situation.
(2) Other entries in $u$ (system time and number of evaluations) are provided for logging only and should not be used to calculate parts of the RHS!

### The by-products of rhs() are unreliable

Since we don't know where $f$ was last evaluated, we don't know which derivatives and intermediary variables are currently in memory.
To perform accurate logging of these values an extra call to the rhs function is needed.
This is implemented in Myokit's CVODE sim, resulting in a few extra RHS() calls (if and only if derivatives or intermediary variables are being logged).

## OpenCL Simulation

In OpenCL simulations, to save memory and memory access time, the derivatives are calculated in local memory (on the device) and used to update the state immediatly.
Thus, after a call to the RHS defined by the kernel we have
\begin{linenomath}
\begin{equation}
t,u\left(t\right),y\left(t+\Delta t\right)
\end{equation}
\end{linenomath}
Derivatives are not currently logged in the OpenCL simulation, but intermediary variables can be made available so that we obtain
\begin{linenomath}
\begin{equation}
t,u\left(t\right),y\left(t+\Delta t\right),i\left(t\right)
\end{equation}
\end{linenomath}
after each call to the RHS.

To implement correct logging, updates in the OpenCL simulations proceed with the following steps:

\begin{enumerate}
\item Check if we need to log at time $t$
\item Determine the $\Delta t$ for the next step
\item Calculate diffusion at time $t$ on the device
\item Logging? Then download the state at time $t$ from the device
\item Update the states on the device to $t+\Delta t$ (which updates the intermediary variables on the device to $t$)
\item Logging? Then download the intermediary and diffusion variables from the device. Write state, intermediary and diffusion variables to log
\item Update time to $t+dt$
\item Update pacing signal to $t+dt$
\end{enumerate}

## Timing

Timing of logging steps is important. There are two conflicting use
cases:
\begin{enumerate}
\item A user runs a single simulation from t0=0 to t1=1000. Next, a plot
is made of these results. This requires t0=0 and t1=1000 to both be
included in the interval.
\item A user runs a simulation from t0=0 to t1=1000. Then a simulation from
t0=1000 to t1=2000. The result should be a log from t=0 to t=2000
without duplicate values.

\begin{enumerate}
\item This can be done by passing log1 in as the log argument to the second
simulation
\item This can be done by logging in two separate logs and then joining
them
\end{enumerate}
\end{enumerate}
For case 1, it would be ideal to always log the initial and final
step. For case 2 it would be better to log half-open intervals (so
include t0 but not t1).

Use case 1 is very common. The most common version of use case 1 is
a single cell simulation with variable steps, simulating exactly one
beat. This means the step sizes at the end of the log become wide,
so that the last step in a 1000ms simulation may be somewhere in the
range 800-900ms.

However, half-open intervals avoid all problems in use-case 2 (while
use case 1 is simply less pretty) and are the defacto standard in
computing (for-loops, python ranges, etc.).

Decision: Split the cases for variable and fixed logging. For variable
logging, log full intervals except when appending. This is slightly
awkward for the situation where logs are appended \emph{outside} of
the simulation, but methods that can deal with variable interval logs
can most-likely deal with this too.


### Logging with variable time-steps

When logging with variable time-steps, a log entry is inserted at
the following stages:
\begin{enumerate}
\item At the start of each simulation, unless appending to an existing log.
\item After each step, including the last.
\end{enumerate}

### Logging with fixed intervals

When logging with fixed log intervals, a log entry is inserted at
the following stages:
\begin{enumerate}
\item At the start of each simulation.
\item \#TODO
\end{enumerate}

