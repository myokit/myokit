#!/usr/bin/env python3
#
# Tests the DiffSL module.
#
# This file is part of Myokit.
# See http://myokit.org for copyright, sharing, and licensing details.
#
import itertools
import os
import unittest

import myokit
import myokit.formats
import myokit.formats.diffsl
import myokit.tests
from myokit import (Abs, ACos, And, ASin, ATan, Ceil, Cos, Divide, Equal, Exp,
                    Floor, If, Less, LessEqual, Log, Log10, Minus, More,
                    MoreEqual, Multiply, Not, NotEqual, Number, Or, Piecewise,
                    Plus, Power, PrefixMinus, PrefixPlus, Quotient, Remainder,
                    Sin, Sqrt, Tan)
from myokit.tests import DIR_DATA, TemporaryDirectory, WarningCollector


# Model from https://github.com/CardiacModelling/VoltageClampModel/
# mmt-model-files/full2-voltage-clamp-ikr-linleak.mmt

input_model = """
[[model]]
membrane.V = -80.0 [mV]
voltageclamp.Vclamp = -80.0 [mV]
voltageclamp.Vp = -80.0 [mV]
voltageclamp.Vest = -80.0 [mV]
voltageclamp.Iout = 0.0 [mV]
ikr.open = 0 [1]
ikr.active = 1 [1]

[ikr]
use membrane.V
IKr = g * open * active * (V - rev.EK)
    in [pA]
dot(open) = (inf - open) / tau
    inf = k1 * tau
    tau = 1 / (k1 + k2)
    k1 = p1 * exp(p2 * V)
    k2 = p3 * exp(-p4 * V)
    in [1]
dot(active) = (inf - active) / tau
    inf = k4 * tau
    tau = 1 / (k3 + k4)
    k3 = p5 * exp(p6 * V)
    k4 = p7 * exp(-p8 * V)
    in [1]
p1 = 2.26e-4 [1/ms]
p2 = 0.0699 [1/mV]
p3 = 3.45e-5 [1/ms]
p4 = 0.05462 [1/mV]
p5 = 0.0873 [1/ms]
p6 = 8.91e-3 [1/mV]
p7 = 5.15e-3 [1/ms]
p8 = 0.03158 [1/mV]
g = 0.1524 * 1e3 [pA/mV]  # in nA range

[engine]
time = 0 bind time
    in [ms]
pace = 0 bind pace

[membrane]
use voltageclamp.Vp, voltageclamp.rseries, voltageclamp.voffset_eff
Iion = ikr.IKr + voltageclamp.ILeak
    in [pA]
cm = 100.0 [pF]
dot(V) = (Vp - V + voffset_eff) / tau - Iion / cm
    tau = cm * rseries in [ms]
    desc: membane potential
    in [mV]

[voltageclamp]
use membrane.V
rseries = 10.0 * 1e-3 [GR]
cprs = 4.0 [pF]
cprs_est = 4.0 * 0.9 [pF]
voffset_eff = 5 [mV]
rseries_est = 0.9 * 10.0e-3 [GR]
cm_est = 0.9 * 100.0 [pF]
alpha = 0.8 [1]

Vc = engine.pace
    desc: command voltage
    in [mV]

tau_sum = 40e-3 in [ms] 
dVclampdt = (Vc + (Iout + cm_est * dVestdt) * rseries_est - Vclamp) / tau_sum
    in [mV/ms]
dot(Vclamp) = dVclampdt
    desc: clamp voltage
    in [mV]

dVestdt = piecewise(
    cm_est < 1e-6, 0,
    rseries_est < 1e-6, 0,
    (Vc - Vest) / ((1 - alpha) * cm_est * rseries_est/alpha)
) in [mV/ms]
dot(Vest) = dVestdt
    in [mV]

tau_clamp = 0.8 * 1e-3 in [ms]
dVpdt = (Vclamp - Vp) / tau_clamp in [mV/ms]
dot(Vp) = dVpdt
    desc: pipette voltage
    in [mV]

dot(Iout) = (Iin - Iout) / tau
    tau = 7.5 * 1e-3 in [ms]
    desc: measured current
    in [pA]

Iin = (
        (Vp - V + voffset_eff) / rseries
        + cprs * dVpdt
        - cprs_est * dVclampdt
        - cm_est * if(rseries_est < 1e-6, dVclampdt, dVestdt)
    )
    in [pA]

gLeak = 2 [pA/mV]
ELeak = -80 [mV]
ILeak = gLeak * (V - ELeak) in [pA]

[potassium]
Ki = 110 [mM]
Ko = 4 [mM]

[rev]
use phys.RTF
EK = RTF * log(potassium.Ko / potassium.Ki)
    in [mV]

[phys]
R = 8.314472 [J/mol/K]
T = 310 [K]  # 36-37oC (BT)
F = 9.64853415e4 [C/mol]
RTF = R * T / F * 1e3 in [mV]
"""

output_model = """
/*
This file was generated by Myokit.
*/

/* Input parameters */
in = [ ]

/* Constants: phys */
physZF { 9.64853414999999950e+04 } /* F */
physZR { 8.314472 } /* R */
physZT { 310.0 } /* T */
physZRTF { physZR * physZT / physZF * 1000.0 } /* RTF [mV] */

/* Constants: potassium */
potassiumZKi { 110.0 } /* Ki */
potassiumZKo { 4.0 } /* Ko */

/* Constants: voltageclamp */
voltageclampZELeak { -80.0 } /* ELeak */
voltageclampZVc { 0.0 } /* Vc [mV] */
voltageclampZalpha { 0.8 } /* alpha */
voltageclampZcmZest { 0.9 * 100.0 } /* cm_est */
voltageclampZcprs { 4.0 } /* cprs */
voltageclampZcprsZest { 4.0 * 0.9 } /* cprs_est */
voltageclampZgLeak { 2.0 } /* gLeak */
voltageclampZrseries { 10.0 * 0.001 } /* rseries */
voltageclampZrseriesZest { 0.9 * 0.01 } /* rseries_est */
voltageclampZtauZclamp { 0.8 * 0.001 } /* tau_clamp [ms] */
voltageclampZtauZsum { 0.04 } /* tau_sum [ms] */
voltageclampZvoffsetZeff { 5.0 } /* voffset_eff */
voltageclampZdotZIoutZtau { 7.5 * 0.001 } /* tau [ms] */

/* Constants: rev */
revZEK { physZRTF * log(potassiumZKo / potassiumZKi) } /* EK [mV] */

/* Constants: ikr */
ikrZg { 0.1524 * 1000.0 } /* g */
ikrZp1 { 0.000226 } /* p1 */
ikrZp2 { 0.0699 } /* p2 */
ikrZp3 { 3.45e-05 } /* p3 */
ikrZp4 { 0.05462 } /* p4 */
ikrZp5 { 0.0873 } /* p5 */
ikrZp6 { 0.00891 } /* p6 */
ikrZp7 { 0.00515 } /* p7 */
ikrZp8 { 0.03158 } /* p8 */

/* Constants: membrane */
membraneZcm { 100.0 } /* cm */
membraneZdotZVZtau { membraneZcm * voltageclampZrseries } /* tau [ms] */

/* Initial conditions */
u_i {
  membraneZV = -80.0, /* V [mV] */
  voltageclampZVclamp = -80.0, /* Vclamp [mV] */
  voltageclampZVp = -80.0, /* Vp [mV] */
  voltageclampZVest = -80.0, /* Vest [mV] */
  voltageclampZIout = 0.0, /* Iout [pA] */
  ikrZopen = 0.0, /* open [1] */
  ikrZactive = 1.0, /* active [1] */
}

dudt_i {
  membraneZdotZV = -80.0,
  voltageclampZdVclampdt = -80.0,
  voltageclampZdVpdt = -80.0,
  voltageclampZdVestdt = -80.0,
  voltageclampZdotZIout = 0.0,
  ikrZdotZopen = 0.0,
  ikrZdotZactive = 1.0,
}

/* Variables: voltageclamp */
voltageclampZILeak { voltageclampZgLeak * (membraneZV - voltageclampZELeak) } /* ILeak [pA] */
voltageclampZIin { (voltageclampZVp - membraneZV + voltageclampZvoffsetZeff) / voltageclampZrseries + voltageclampZcprs * voltageclampZdVpdt - voltageclampZcprsZest * voltageclampZdVclampdt - voltageclampZcmZest * (voltageclampZdVclampdt * (1 - heaviside(voltageclampZrseriesZest - 1e-06)) + voltageclampZdVestdt * heaviside(voltageclampZrseriesZest - 1e-06)) } /* Iin [pA] */

/* Variables: ikr */
ikrZIKr { ikrZg * ikrZopen * ikrZactive * (membraneZV - revZEK) } /* IKr [pA] */
ikrZdotZactiveZk3 { ikrZp5 * exp(ikrZp6 * membraneZV) } /* k3 */
ikrZdotZactiveZk4 { ikrZp7 * exp(-ikrZp8 * membraneZV) } /* k4 */
ikrZdotZactiveZtau { 1.0 / (ikrZdotZactiveZk3 + ikrZdotZactiveZk4) } /* tau */
ikrZdotZactiveZinf { ikrZdotZactiveZk4 * ikrZdotZactiveZtau } /* inf */
ikrZdotZopenZk1 { ikrZp1 * exp(ikrZp2 * membraneZV) } /* k1 */
ikrZdotZopenZk2 { ikrZp3 * exp(-ikrZp4 * membraneZV) } /* k2 */
ikrZdotZopenZtau { 1.0 / (ikrZdotZopenZk1 + ikrZdotZopenZk2) } /* tau */
ikrZdotZopenZinf { ikrZdotZopenZk1 * ikrZdotZopenZtau } /* inf */

/* Variables: membrane */
membraneZIion { ikrZIKr + voltageclampZILeak } /* Iion [pA] */

F_i {
  membraneZdotZV,
  voltageclampZdVclampdt,
  voltageclampZdVpdt,
  voltageclampZdVestdt,
  voltageclampZdotZIout,
  ikrZdotZopen,
  ikrZdotZactive,
}

G_i {
  (voltageclampZVp - membraneZV + voltageclampZvoffsetZeff) / membraneZdotZVZtau - membraneZIion / membraneZcm,
  (voltageclampZVc + (voltageclampZIout + voltageclampZcmZest * voltageclampZdVestdt) * voltageclampZrseriesZest - voltageclampZVclamp) / voltageclampZtauZsum,
  (voltageclampZVclamp - voltageclampZVp) / voltageclampZtauZclamp,
  (voltageclampZVc - voltageclampZVest) / ((1.0 - voltageclampZalpha) * voltageclampZcmZest * voltageclampZrseriesZest / voltageclampZalpha) * heaviside(voltageclampZrseriesZest - 1e-06) * heaviside(voltageclampZcmZest - 1e-06),
  (voltageclampZIin - voltageclampZIout) / voltageclampZdotZIoutZtau,
  (ikrZdotZopenZinf - ikrZopen) / ikrZdotZopenZtau,
  (ikrZdotZactiveZinf - ikrZactive) / ikrZdotZactiveZtau,
}

/* Output all currents and state variables */
out_i {
  ikrZactive,
  ikrZopen,
  membraneZV,
  membraneZdotZV,
  voltageclampZIout,
  voltageclampZVclamp,
  voltageclampZVest,
  voltageclampZVp,
}
"""


class DiffSLExporterTest(unittest.TestCase):
    """ Tests DiffSL export. """

    def test_diffsl_exporter(self):
        # Tests exporting a model

        model = myokit.load_model('example')
        with TemporaryDirectory() as d:
            path = d.path('easy.model')

            # Test with simple model
            e = myokit.formats.diffsl.DiffSLExporter()
            e.model(path, model)

            # Test with extra bound variables
            model.get('membrane.C').set_binding('hello')
            e.model(path, model)

            # Test without V being a state variable
            v = model.get('membrane.V')
            v.demote()
            v.set_rhs(3)
            e.model(path, model)

            # Test with invalid model
            v.set_rhs('2 * V')
            self.assertRaisesRegex(
                myokit.ExportError, 'valid model', e.model, path, model)

    def test_diffsl_exporter_static(self):
        # Tests exporting a model (with HH and markov states) and compares
        # against reference output.

        # Export model
        m = myokit.load_model(os.path.join(DIR_DATA, 'decker-2009.mmt'))
        e = myokit.formats.diffsl.DiffSLExporter()
        with TemporaryDirectory() as d:
            path = d.path('decker.model')
            e.model(path, m)
            with open(path, 'r') as f:
                observed = f.readlines()

        # Load expected output
        with open(os.path.join(DIR_DATA, 'decker.model'), 'r') as f:
            expected = f.readlines()

        # Compare (line by line, for readable output)
        for ob, ex in zip(observed, expected):
            self.assertEqual(ob, ex)
        self.assertEqual(len(observed), len(expected))

    def test_unit_conversion(self):
        # Tests exporting a model that requires unit conversion

        # Export model
        m = myokit.parse_model(input_model)
        e = myokit.formats.diffsl.DiffSLExporter()
        with TemporaryDirectory() as d:
            path = d.path('easy.model')
            e.model(path, m)
            with open(path, 'r') as f:
                observed = f.read().strip().splitlines()

        # Get expected output
        expected = output_model.strip().splitlines()

        # Compare (line by line, for readable output)
        for ob, ex in zip(observed, expected):
            self.assertEqual(ob, ex)
        self.assertEqual(len(observed), len(expected))

        # Test warnings are raised if conversion fails
        m.get('membrane.V').set_rhs('hh.I1 + mm.I2')
        m.get('membrane').remove_variable(m.get('membrane.C'))
        with TemporaryDirectory() as d:
            path = d.path('easy.model')
            with WarningCollector() as c:
                e.model(path, m)
            self.assertIn('Unable to convert hh.I1', c.text())
            self.assertIn('Unable to convert mm.I2', c.text())

        m.get('engine.time').set_unit(myokit.units.cm)
        with TemporaryDirectory() as d:
            path = d.path('easy.model')
            with WarningCollector() as c:
                e.model(path, m)
            self.assertIn('Unable to convert time units [cm]', c.text())

    def test_export_reused_variable(self):
        # Tests exporting when an `inf` or other special variable is used twice

        # Create model re-using tau and inf
        m = myokit.parse_model(
            """
            [[model]]
            m.V = -80
            c.x = 0.1
            c.y = 0.1

            [m]
            time = 0 bind time
            i_ion = c.I
            dot(V) = -i_ion

            [c]
            inf = 0.5
            tau = 3
            dot(x) = (inf - x) / tau
            dot(y) = (inf - y) / tau
            I = x * y * (m.V - 50)
            """)

        # Export, and read back in
        e = myokit.formats.diffsl.DiffSLExporter()
        with TemporaryDirectory() as d:
            path = d.path('easy.model')
            e.model(path, m)
            with open(path, 'r') as f:
                x = f.read()

        self.assertIn('x_inf {', x)
        self.assertIn('y_inf {', x)
        self.assertIn('tau_x {', x)
        self.assertIn('tau_y {', x)

    def test_diffsl_exporter_fetching(self):
        # Tests getting an DiffSL exporter via the 'exporter' interface

        e = myokit.formats.exporter('diffsl')
        self.assertIsInstance(e, myokit.formats.diffsl.DiffSLExporter)

    def test_capability_reporting(self):
        # Tests if the correct capabilities are reported
        e = myokit.formats.diffsl.DiffSLExporter()
        self.assertTrue(e.supports_model())


class DiffSLExpressionWriterTest(myokit.tests.ExpressionWriterTestCase):
    """Test conversion to DiffSL syntax."""

    _name = 'diffsl'
    _target = myokit.formats.diffsl.DiffSLExpressionWriter

    def test_number(self):
        self.eq(Number(1), '1.0')
        self.eq(Number(-2), '-2.0')
        self.eq(Number(13, 'mV'), '13.0')

    def test_name(self):
        # Inherited from CBasedExpressionWriter
        self.eq(self.a, 'a')
        w = self._target()
        w.set_lhs_function(lambda v: v.var().qname().upper())
        self.assertEqual(w.ex(self.a), 'COMP.A')

    def test_derivative(self):
        # Inherited from CBasedExpressionWriter
        self.eq(myokit.Derivative(self.a), 'dadt')

    def test_partial_derivative(self):
        e = myokit.PartialDerivative(self.a, self.b)
        self.assertRaisesRegex(NotImplementedError, 'Partial', self.w.ex, e)

    def test_initial_value(self):
        e = myokit.InitialValue(self.a)
        self.assertRaisesRegex(NotImplementedError, 'Initial', self.w.ex, e)

    def test_prefix_plus_minus(self):
        # Inherited from CBasedExpressionWriter
        p = Number(11, 'kV')
        a, b, c = self.abc
        self.eq(PrefixPlus(p), '+11.0')
        self.eq(PrefixPlus(PrefixPlus(PrefixPlus(p))), '+(+(+11.0))')
        self.eq(Divide(PrefixPlus(Plus(a, b)), c), '+(a + b) / c')
        self.eq(PrefixMinus(p), '-11.0')
        self.eq(PrefixMinus(PrefixMinus(p)), '-(-11.0)')
        self.eq(PrefixMinus(Number(-1)), '-(-1.0)')
        self.eq(PrefixMinus(Minus(a, b)), '-(a - b)')
        self.eq(Multiply(PrefixMinus(Plus(b, a)), c), '-(b + a) * c')
        self.eq(PrefixMinus(Divide(b, a)), '-(b / a)')

    def test_plus_minus(self):
        a, b, c = self.abc
        self.eq(Plus(a, b), 'a + b')
        self.eq(Plus(Plus(a, b), c), 'a + b + c')
        self.eq(Plus(a, Plus(b, c)), 'a + (b + c)')

        self.eq(Minus(a, b), 'a - b')
        self.eq(Minus(Minus(a, b), c), 'a - b - c')
        self.eq(Minus(a, Minus(b, c)), 'a - (b - c)')

        self.eq(Minus(a, b), 'a - b')
        self.eq(Plus(Minus(a, b), c), 'a - b + c')
        self.eq(Minus(a, Plus(b, c)), 'a - (b + c)')
        self.eq(Minus(Plus(a, b), c), 'a + b - c')
        self.eq(Minus(a, Plus(b, c)), 'a - (b + c)')

        # No expm in DiffSL
        self.eq(Minus(Exp(Number(2)), Number(1)), 'exp(2.0) - 1.0')
        self.eq(Minus(Number(1), Exp(Number(3))), '1.0 - exp(3.0)')

    def test_multiply_divide(self):
        # Inherited from CBasedExpressionWriter
        a, b, c = self.abc
        self.eq(Multiply(a, b), 'a * b')
        self.eq(Multiply(Multiply(a, b), c), 'a * b * c')
        self.eq(Multiply(a, Multiply(b, c)), 'a * (b * c)')
        self.eq(Divide(a, b), 'a / b')
        self.eq(Divide(Divide(a, b), c), 'a / b / c')
        self.eq(Divide(a, Divide(b, c)), 'a / (b / c)')

    def test_quotient(self):
        # Inherited from CBasedExpressionWriter
        a, b, c = self.abc
        with WarningCollector():
            self.eq(Quotient(a, b), 'floor(a / b)')
            self.eq(Quotient(Plus(a, c), b), 'floor((a + c) / b)')
            self.eq(Quotient(Divide(a, c), b), 'floor(a / c / b)')
            self.eq(Quotient(a, Divide(b, c)), 'floor(a / (b / c))')
            self.eq(Multiply(Quotient(a, b), c), 'floor(a / b) * c')
            self.eq(Multiply(c, Quotient(a, b)), 'c * (floor(a / b))')

    def test_remainder(self):
        # Inherited from CBasedExpressionWriter
        a, b, c = self.abc
        with WarningCollector():
            self.eq(Remainder(a, b), '(a - b * floor(a / b))')
            self.eq(Remainder(Plus(a, c), b),
                    '(a + c - b * floor((a + c) / b))')
            self.eq(Multiply(Remainder(a, b), c), '(a - b * floor(a / b)) * c')
            self.eq(Divide(c, Remainder(b, a)), 'c / ((b - a * floor(b / a)))')

    def test_power(self):
        # Inherited from CBasedExpressionWriter
        a, b, c = self.abc
        self.eq(Power(a, b), 'pow(a, b)')
        self.eq(Power(Power(a, b), c), 'pow(pow(a, b), c)')
        self.eq(Power(a, Power(b, c)), 'pow(a, pow(b, c))')

    def test_log(self):
        # Inherited from CBasedExpressionWriter
        a, b = self.ab
        self.eq(Log(a), 'log(a)')
        self.eq(Log10(a), '(log(a) / log(10.0))')
        self.eq(Log(a, b), '(log(a) / log(b))')

    def test_supported_functions(self):
        a = self.a

        self.eq(Abs(a), 'abs(a)')
        self.eq(Cos(a), 'cos(a)')
        self.eq(Exp(a), 'exp(a)')
        self.eq(Log(a), 'log(a)')
        self.eq(Sin(a), 'sin(a)')
        self.eq(Sqrt(a), 'sqrt(a)')
        self.eq(Tan(a), 'tan(a)')

    def test_unsupported_functions(self):
        a = self.a

        with WarningCollector() as wc:
            self.eq(ACos(a), 'acos(a)')
        self.assertIn('Unsupported', wc.text())

        with WarningCollector() as wc:
            self.eq(ASin(a), 'asin(a)')
        self.assertIn('Unsupported', wc.text())

        with WarningCollector() as wc:
            self.eq(ATan(a), 'atan(a)')
        self.assertIn('Unsupported', wc.text())

        with WarningCollector() as wc:
            self.eq(Ceil(a), 'ceil(a)')
        self.assertIn('Unsupported', wc.text())

        with WarningCollector() as wc:
            self.eq(Floor(a), 'floor(a)')
        self.assertIn('Unsupported', wc.text())

    def test_conditional_operators(self):
        a, b, c, d = self.abcd

        self.eq(Equal(a, b), 'heaviside(a - b) * heaviside(b - a)')

        self.eq(Less(a, b), '(1 - heaviside(a - b))')

        self.eq(LessEqual(a, b), 'heaviside(b - a)')

        self.eq(More(a, b), '(1 - heaviside(b - a))')

        self.eq(MoreEqual(a, b), 'heaviside(a - b)')

        self.eq(NotEqual(a, b), '(1 - heaviside(a - b) * heaviside(b - a))')

        self.eq(Not(NotEqual(a, b)), 'heaviside(a - b) * heaviside(b - a)')

        self.eq(Not(Not(Equal(a, b))), 'heaviside(a - b) * heaviside(b - a)')

        self.eq(And(Equal(a, b), NotEqual(c, d)),
                'heaviside(a - b) * heaviside(b - a)'
                ' * (1 - heaviside(c - d) * heaviside(d - c))')

        self.eq(Or(More(d, c), MoreEqual(b, a)),
                '(1 - heaviside(c - d) * (1 - heaviside(b - a)))')

        self.eq(Or(Less(d, c), LessEqual(b, a)),
                '(1 - heaviside(d - c) * (1 - heaviside(a - b)))')

        self.eq(Not(Or(Equal(Number(1), Number(2)),
                       Equal(Number(3), Number(4)))),
                '(1 - heaviside(1.0 - 2.0) * heaviside(2.0 - 1.0))'
                ' * (1 - heaviside(3.0 - 4.0) * heaviside(4.0 - 3.0))')

        self.eq(Not(Less(Number(1), Number(2))), 'heaviside(1.0 - 2.0)')

    def test_if_expressions(self):
        a, b, c, d = self.abcd

        self.eq(If(Equal(a, b), c, d),
                '(c * heaviside(a - b) * heaviside(b - a)'
                ' + d * (1 - heaviside(a - b) * heaviside(b - a)))')

        self.eq(If(Equal(a, b), c, Number(0)),
                'c * heaviside(a - b) * heaviside(b - a)')

        self.eq(If(Equal(a, b), Number(0), d),
                'd * (1 - heaviside(a - b) * heaviside(b - a))')

        self.eq(If(NotEqual(a, b), c, d),
                '(c * (1 - heaviside(a - b) * heaviside(b - a))'
                ' + d * heaviside(a - b) * heaviside(b - a))')

        self.eq(If(More(a, b), c, d),
                '(c * (1 - heaviside(b - a)) + d * heaviside(b - a))')

        self.eq(If(MoreEqual(a, b), c, d),
                '(c * heaviside(a - b) + d * (1 - heaviside(a - b)))')

        self.eq(If(Less(a, b), c, d),
                '(c * (1 - heaviside(a - b)) + d * heaviside(a - b))')

        self.eq(If(LessEqual(a, b), c, d),
                '(c * heaviside(b - a) + d * (1 - heaviside(b - a)))')

    def test_piecewise_expressions(self):
        a, b, c, d = self.abcd

        self.eq(Piecewise(Equal(a, b), c, d), self.w.ex(If(Equal(a, b), c, d)))

        self.eq(Piecewise(NotEqual(a, b), c, d),
                self.w.ex(If(NotEqual(a, b), c, d),))

        self.eq(Piecewise(More(a, b), c, d), self.w.ex(If(More(a, b), c, d),))

        self.eq(Piecewise(MoreEqual(a, b), c, d),
                self.w.ex(If(MoreEqual(a, b), c, d)))

        self.eq(Piecewise(Less(a, b), c, d), self.w.ex(If(Less(a, b), c, d)))

        self.eq(Piecewise(LessEqual(a, b), c, d),
                self.w.ex(If(LessEqual(a, b), c, d),))

        self.eq(Piecewise(Equal(a, b), c,
                          Equal(a, d), Number(3),
                          Number(4)),
                self.w.ex(If(Equal(a, b), c,
                             If(Equal(a, d), Number(3),
                                Number(4)))))

        self.eq(Piecewise(Less(a, b), Number(0),
                          Less(c, d), Number(0),
                          Number(5)),
                '5.0 * heaviside(c - d) * heaviside(a - b)')

    def test_heaviside_numerical(self):
        """ Test generated heaviside expressions with numerical values """

        def heaviside(x):
            return 1 if x >= 0 else 0

        values = itertools.product([-10e9, -1, -1e-9, 0, 1e-9, 1, 10e9],
                                   repeat=4)

        for a, b, c, d in values:
            # a == b
            result = int(a == b)
            expr = self.w.ex(Equal(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # a < b
            result = int(a < b)
            expr = self.w.ex(Less(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # a <= b
            result = int(a <= b)
            expr = self.w.ex(LessEqual(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # a > b
            result = int(a > b)
            expr = self.w.ex(More(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # a >= b
            result = int(a >= b)
            expr = self.w.ex(MoreEqual(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # a != b
            result = int(a != b)
            expr = self.w.ex(NotEqual(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # not(a != b)
            result = int(not (a != b))
            expr = self.w.ex(Not(NotEqual(Number(a), Number(b))))
            self.assertEqual(eval(expr), result)

            # not(not(a == b))
            result = int(not (not (a == b)))
            expr = self.w.ex(Not(Not(Equal(Number(a), Number(b)))))
            self.assertEqual(eval(expr), result)

            # (a == b) and (c != d)
            result = int((a == b) and (c != d))
            expr = self.w.ex(And(Equal(Number(a), Number(b)),
                                 NotEqual(Number(c), Number(d))))
            self.assertEqual(eval(expr), result)

            # (d > c) or (b >= a)
            result = int((d > c) or (b >= a))
            expr = self.w.ex(Or(More(Number(d), Number(c)),
                                MoreEqual(Number(b), Number(a))))
            self.assertEqual(eval(expr), result)

            # (d < c) or (b <= a)
            result = int((d < c) or (b <= a))
            expr = self.w.ex(Or(Less(Number(d), Number(c)),
                                LessEqual(Number(b), Number(a))))
            self.assertEqual(eval(expr), result)

            # (a == b) or (c == d)
            result = int((a == b) or (c == d))
            expr = self.w.ex(Or(Equal(Number(a), Number(b)),
                                Equal(Number(c), Number(d))))
            self.assertEqual(eval(expr), result)

            # not(a < b)
            result = int(not (a < b))
            expr = self.w.ex(Not(Less(Number(a), Number(b))))
            self.assertEqual(eval(expr), result)

            # if(a > b, c, d)
            result = c if (a > b) else d
            expr = self.w.ex(If(More(Number(a), Number(b)),
                                Number(c),
                                Number(d)))
            self.assertEqual(eval(expr), result)

            # if(a >= b, c, d)
            result = c if (a >= b) else d
            expr = self.w.ex(If(MoreEqual(Number(a), Number(b)),
                                Number(c),
                                Number(d)))
            self.assertEqual(eval(expr), result)

            # if(a < b, c, d)
            result = c if (a < b) else d
            expr = self.w.ex(If(Less(Number(a), Number(b)),
                                Number(c),
                                Number(d)))
            self.assertEqual(eval(expr), result)

            # if(a <= b, c, d)
            result = c if (a <= b) else d
            expr = self.w.ex(If(LessEqual(Number(a), Number(b)),
                                Number(c),
                                Number(d)))
            self.assertEqual(eval(expr), result)

            # piecewise(a > b, c, d)
            result = c if (a > b) else d
            expr = self.w.ex(Piecewise(More(Number(a), Number(b)),
                                       Number(c),
                                       Number(d)))
            self.assertEqual(eval(expr), result)

            # piecewise(a >= b, c, d)
            result = c if (a >= b) else d
            expr = self.w.ex(Piecewise(MoreEqual(Number(a),
                                                 Number(b)),
                                       Number(c),
                                       Number(d)))
            self.assertEqual(eval(expr), result)

            # piecewise(a < b, c, d)
            result = c if (a < b) else d
            expr = self.w.ex(Piecewise(Less(Number(a), Number(b)),
                                       Number(c),
                                       Number(d)))
            self.assertEqual(eval(expr), result)

            # piecewise(a <= b, c, d)
            result = c if (a <= b) else d
            expr = self.w.ex(Piecewise(LessEqual(Number(a),
                                                 Number(b)),
                                       Number(c),
                                       Number(d)))
            self.assertEqual(eval(expr), result)

            # piecewise(a == b, c, a == d, 3, 4)
            result = c if (a == b) else (3 if (a == d) else 4)
            expr = self.w.ex(Piecewise(Equal(Number(a), Number(b)), Number(c),
                                       Equal(Number(a), Number(d)), Number(3),
                                       Number(4)))
            self.assertEqual(eval(expr), result)

            # piecewise(a < b, 0, c < d, 0, 5)
            result = 0 if (a < b) else (0 if (c < d) else 5)
            expr = self.w.ex(Piecewise(Less(Number(a), Number(b)), Number(0),
                                       Less(Number(c), Number(d)), Number(0),
                                       Number(5)),)
            self.assertEqual(eval(expr), result)


if __name__ == '__main__':
    unittest.main()
