#!/usr/bin/env python3
#
# Tests the DiffSL module.
#
# This file is part of Myokit.
# See http://myokit.org for copyright, sharing, and licensing details.
#
import itertools
import os
import unittest

import myokit
import myokit.formats
import myokit.formats.diffsl
import myokit.tests
from myokit import (Abs, ACos, And, ASin, ATan, Ceil, Cos, Divide, Equal, Exp,
                    Floor, If, Less, LessEqual, Log, Log10, Minus, More,
                    MoreEqual, Multiply, Not, NotEqual, Number, Or, Piecewise,
                    Plus, Power, PrefixMinus, PrefixPlus, Quotient, Remainder,
                    Sin, Sqrt, Tan)
from myokit.tests import DIR_DATA, TemporaryDirectory, WarningCollector

# Model that requires unit conversion
units_model = """
[[model]]
mbrn.V = -0.08
hh.x = 0.1
hh.y = 0.9
mm.C = 0.9

[engine]
pace = 0 bind pace
time = 0 [s]
    in [s]
    bind time

[ideal]
Vc = engine.pace * 1

[mbrn]
dot(V) = (hh.I1 + mm.I2 + F_i.I3) / C
    in [V]
C = 20 [pF]
    in [pF]

Va = 0.1 * dot(V)

[hh]
dot(x) = (inf - x) / tau
    inf = 0.8
    tau = 3 [s]
        in [s]
dot(y) = alpha * (1 - y) - beta * y
    alpha = 0.1 [1/s]
        in [1/s]
    beta = 0.2 [1/s]
        in [1/s]
I1 = 3 [pS] * x * y * (mbrn.V - 0.05 [V])
    in [pA]

[mm]
dot_C = beta * O - alpha * C
dot(C) = dot_C
alpha = 0.3 [1/s]
    in [1/s]
beta = 0.4 [1/s]
    in [1/s]
O = 1 - C
I2 = 2 [pS] * O * (mbrn.V + 0.02 [V])
    in [pA]

[F_i]
I3 = 2 [pS] * mm.O * (mbrn.V + 0.02 [V])
I_0_1 = 1 [pA]
IZ0_1 = 1 [pA]
IZ0Z1 = 1 [pA]
"""

units_output = """
/*
This file was generated by Myokit.
*/

/* Input parameters */
in = [ ]

/* Voltage protocol [mV] */
Vc { -80 + 120 * heaviside(t-500) - 80 * heaviside(t-1000) }

/* Constants: hh */
hhZdotZxZinf { 0.8 } /* hh.dot_x.inf */
hhZdotZxZtau { 3.0 * 1000.0 } /* hh.dot_x.tau [s] */
hhZdotZyZalpha { 0.1 * 0.001 } /* hh.dot_y.alpha [S/F] */
hhZdotZyZbeta { 0.2 * 0.001 } /* hh.dot_y.beta [S/F] */

/* Constants: mm */
mmZalpha { 0.3 } /* mm.alpha [S/F] */
mmZbeta { 0.4 } /* mm.beta [S/F] */

/* Constants: F_i */
varZFZiZIZ0Z1Z1 { 1.0 } /* F_i.IZ0Z1 */
varZFZiZIZ0Z1Z2 { 1.0 } /* F_i.IZ0_1 */
varZFZiZIZ0Z1Z3 { 1.0 } /* F_i.I_0_1 */

/* Constants: mbrn */
mbrnZC { 20.0 } /* mbrn.C [pF] */

/* Initial conditions */
u_i {
  mbrnZV = -80.0, /* mbrn.V [mV] */
  hhZx = 0.1, /* hh.x */
  hhZy = 0.9, /* hh.y */
  mmZC = 0.9, /* mm.C */
}

dudt_i {
  mbrnZdotZV = -80.0,
  hhZdotZx = 0.1,
  hhZdotZy = 0.9,
  mmZdotZCZ1 = 0.9,
}

/* Variables: hh */
hhZI1 { 3.0 * hhZx * hhZy * (mbrnZV / 1000.0 - 0.05) * 0.05 } /* hh.I1 [A/F] */

/* Variables: mm */
mmZO { 1.0 - mmZC } /* mm.O */
mmZI2 { 2.0 * mmZO * (mbrnZV / 1000.0 + 0.02) * 0.05 } /* mm.I2 [A/F] */
mmZdotZC { mmZbeta * mmZO - mmZalpha * mmZC } /* mm.dot_C */

/* Variables: F_i */
varZFZiZI3 { 2.0 * mmZO * (mbrnZV / 1000.0 + 0.02) } /* F_i.I3 */

/* Variables: ideal */
idealZVc { Vc * 1.0 } /* ideal.Vc */

/* Variables: mbrn */
mbrnZVa { 0.1 * (mbrnZdotZV / 1000.0) } /* mbrn.Va */

/* Solve */
F_i {
  mbrnZdotZV,
  hhZdotZx,
  hhZdotZy,
  mmZdotZCZ1,
}

G_i {
  (hhZI1 / 0.05 + mmZI2 / 0.05 + varZFZiZI3) / mbrnZC * 1000.0 * 0.001,
  (hhZdotZxZinf - hhZx) / hhZdotZxZtau * 0.001,
  (hhZdotZyZalpha * (1.0 - hhZy) - hhZdotZyZbeta * hhZy) * 0.001,
  mmZdotZC * 0.001,
}

/* Output */
out_i {
  varZFZiZI3,
  hhZI1,
  hhZx,
  hhZy,
  mbrnZV,
  mmZC,
  mmZI2,
}
"""


class DiffSLExporterTest(unittest.TestCase):
    """Tests DiffSL export."""

    def test_diffsl_exporter(self):
        # Tests exporting a model

        model = myokit.load_model('example')
        with TemporaryDirectory() as d:
            path = d.path('diffsl.model')

            e = myokit.formats.diffsl.DiffSLExporter()

            # Test with simple model
            e.model(path, model)

            # Test with extra bound variables
            model.get('membrane.C').set_binding('hello')
            e.model(path, model)

            # Test without V being a state variable
            v = model.get('membrane.V')
            v.demote()
            v.set_rhs(3)
            e.model(path, model)

            # Test with invalid model
            v.set_rhs('2 * V')
            self.assertRaisesRegex(
                myokit.ExportError, 'valid model', e.model, path, model
            )

    def test_diffsl_exporter_static(self):
        # Tests exporting a model (with HH and markov states) and compares
        # against reference output.

        # Export model
        m = myokit.load_model(os.path.join(DIR_DATA, 'decker-2009.mmt'))
        e = myokit.formats.diffsl.DiffSLExporter()
        with TemporaryDirectory() as d:
            path = d.path('decker.model')
            e.model(path, m)
            with open(path, 'r') as f:
                observed = f.readlines()

        # Load expected output
        with open(os.path.join(DIR_DATA, 'decker-2009.diffsl'), 'r') as f:
            expected = f.readlines()

        # Compare (line by line, for readable output)
        for ob, ex in zip(observed, expected):
            self.assertEqual(ob, ex)
        self.assertEqual(len(observed), len(expected))

    def test_unit_conversion(self):
        # Tests exporting a model that requires unit conversion

        # Export model
        m = myokit.parse_model(units_model)
        e = myokit.formats.diffsl.DiffSLExporter()
        with TemporaryDirectory() as d:
            path = d.path('diffsl.model')
            e.model(path, m)
            with open(path, 'r') as f:
                observed = f.read().strip().splitlines()

        # Get expected output
        expected = units_output.strip().splitlines()

        # Compare (line by line, for readable output)
        for ob, ex in zip(observed, expected):
            self.assertEqual(ob, ex)
        self.assertEqual(len(observed), len(expected))

        # Check time and V conversion is not done if in ms and mV
        m.get('engine.time').set_unit(myokit.units.ms)
        m.get('mbrn.V').set_unit(myokit.units.mV)
        with TemporaryDirectory() as d:
            path = d.path('diffsl.model')
            e.model(path, m)
            with open(path, 'r') as f:
                observed = f.read().strip()
        self.assertNotIn('* 1000.0', observed)
        self.assertNotIn('* 0.001', observed)

        # Test warnings are raised if conversion fails
        m.get('mbrn.V').set_rhs('hh.I1 + mm.I2')
        m.get('mbrn').remove_variable(m.get('mbrn.C'))
        with TemporaryDirectory() as d:
            path = d.path('diffsl.model')
            with WarningCollector() as c:
                e.model(path, m)
            self.assertIn('Unable to convert hh.I1', c.text())
            self.assertIn('Unable to convert mm.I2', c.text())

        m.get('engine.time').set_unit(myokit.units.cm)
        with TemporaryDirectory() as d:
            path = d.path('diffsl.model')
            with WarningCollector() as c:
                e.model(path, m)
            self.assertIn('Unable to convert time units [cm]', c.text())

    def test_diffsl_exporter_fetching(self):
        # Tests getting an DiffSL exporter via the 'exporter' interface

        e = myokit.formats.exporter('diffsl')
        self.assertIsInstance(e, myokit.formats.diffsl.DiffSLExporter)

    def test_capability_reporting(self):
        # Tests if the correct capabilities are reported
        e = myokit.formats.diffsl.DiffSLExporter()
        self.assertTrue(e.supports_model())


class DiffSLExpressionWriterTest(myokit.tests.ExpressionWriterTestCase):
    """Test conversion to DiffSL syntax."""

    _name = 'diffsl'
    _target = myokit.formats.diffsl.DiffSLExpressionWriter

    def test_number(self):
        self.eq(Number(1), '1.0')
        self.eq(Number(-2), '-2.0')
        self.eq(Number(13, 'mV'), '13.0')

    def test_name(self):
        # Inherited from CBasedExpressionWriter
        self.eq(self.a, 'a')
        w = self._target()
        w.set_lhs_function(lambda v: v.var().qname().upper())
        self.assertEqual(w.ex(self.a), 'COMP.A')

    def test_derivative(self):
        # Inherited from CBasedExpressionWriter
        self.eq(myokit.Derivative(self.a), 'dot(a)')

    def test_partial_derivative(self):
        e = myokit.PartialDerivative(self.a, self.b)
        self.assertRaisesRegex(NotImplementedError, 'Partial', self.w.ex, e)

    def test_initial_value(self):
        e = myokit.InitialValue(self.a)
        self.assertRaisesRegex(NotImplementedError, 'Initial', self.w.ex, e)

    def test_prefix_plus_minus(self):
        # Inherited from CBasedExpressionWriter
        p = Number(11, 'kV')
        a, b, c = self.abc
        self.eq(PrefixPlus(p), '+11.0')
        self.eq(PrefixPlus(PrefixPlus(PrefixPlus(p))), '+(+(+11.0))')
        self.eq(Divide(PrefixPlus(Plus(a, b)), c), '+(a + b) / c')
        self.eq(PrefixMinus(p), '-11.0')
        self.eq(PrefixMinus(PrefixMinus(p)), '-(-11.0)')
        self.eq(PrefixMinus(Number(-1)), '-(-1.0)')
        self.eq(PrefixMinus(Minus(a, b)), '-(a - b)')
        self.eq(Multiply(PrefixMinus(Plus(b, a)), c), '-(b + a) * c')
        self.eq(PrefixMinus(Divide(b, a)), '-(b / a)')

    def test_plus_minus(self):
        a, b, c = self.abc
        self.eq(Plus(a, b), 'a + b')
        self.eq(Plus(Plus(a, b), c), 'a + b + c')
        self.eq(Plus(a, Plus(b, c)), 'a + (b + c)')

        self.eq(Minus(a, b), 'a - b')
        self.eq(Minus(Minus(a, b), c), 'a - b - c')
        self.eq(Minus(a, Minus(b, c)), 'a - (b - c)')

        self.eq(Minus(a, b), 'a - b')
        self.eq(Plus(Minus(a, b), c), 'a - b + c')
        self.eq(Minus(a, Plus(b, c)), 'a - (b + c)')
        self.eq(Minus(Plus(a, b), c), 'a + b - c')
        self.eq(Minus(a, Plus(b, c)), 'a - (b + c)')

        # No expm in DiffSL
        self.eq(Minus(Exp(Number(2)), Number(1)), 'exp(2.0) - 1.0')
        self.eq(Minus(Number(1), Exp(Number(3))), '1.0 - exp(3.0)')

    def test_multiply_divide(self):
        # Inherited from CBasedExpressionWriter
        a, b, c = self.abc
        self.eq(Multiply(a, b), 'a * b')
        self.eq(Multiply(Multiply(a, b), c), 'a * b * c')
        self.eq(Multiply(a, Multiply(b, c)), 'a * (b * c)')
        self.eq(Divide(a, b), 'a / b')
        self.eq(Divide(Divide(a, b), c), 'a / b / c')
        self.eq(Divide(a, Divide(b, c)), 'a / (b / c)')

    def test_quotient(self):
        # Inherited from CBasedExpressionWriter
        a, b, c = self.abc
        with WarningCollector():
            self.eq(Quotient(a, b), 'floor(a / b)')
            self.eq(Quotient(Plus(a, c), b), 'floor((a + c) / b)')
            self.eq(Quotient(Divide(a, c), b), 'floor(a / c / b)')
            self.eq(Quotient(a, Divide(b, c)), 'floor(a / (b / c))')
            self.eq(Multiply(Quotient(a, b), c), 'floor(a / b) * c')
            self.eq(Multiply(c, Quotient(a, b)), 'c * (floor(a / b))')

    def test_remainder(self):
        # Inherited from CBasedExpressionWriter
        a, b, c = self.abc
        with WarningCollector():
            self.eq(Remainder(a, b), '(a - b * floor(a / b))')
            self.eq(
                Remainder(Plus(a, c), b), '(a + c - b * floor((a + c) / b))'
            )
            self.eq(Multiply(Remainder(a, b), c), '(a - b * floor(a / b)) * c')
            self.eq(Divide(c, Remainder(b, a)), 'c / ((b - a * floor(b / a)))')

    def test_power(self):
        # Inherited from CBasedExpressionWriter
        a, b, c = self.abc
        self.eq(Power(a, b), 'pow(a, b)')
        self.eq(Power(Power(a, b), c), 'pow(pow(a, b), c)')
        self.eq(Power(a, Power(b, c)), 'pow(a, pow(b, c))')

    def test_log(self):
        # Inherited from CBasedExpressionWriter
        a, b = self.ab
        self.eq(Log(a), 'log(a)')
        self.eq(Log10(a), '(log(a) / log(10.0))')
        self.eq(Log(a, b), '(log(a) / log(b))')

    def test_supported_functions(self):
        a = self.a

        self.eq(Abs(a), 'abs(a)')
        self.eq(Cos(a), 'cos(a)')
        self.eq(Exp(a), 'exp(a)')
        self.eq(Log(a), 'log(a)')
        self.eq(Sin(a), 'sin(a)')
        self.eq(Sqrt(a), 'sqrt(a)')
        self.eq(Tan(a), 'tan(a)')

    def test_unsupported_functions(self):
        a = self.a

        with WarningCollector() as wc:
            self.eq(ACos(a), 'acos(a)')
        self.assertIn('Unsupported', wc.text())

        with WarningCollector() as wc:
            self.eq(ASin(a), 'asin(a)')
        self.assertIn('Unsupported', wc.text())

        with WarningCollector() as wc:
            self.eq(ATan(a), 'atan(a)')
        self.assertIn('Unsupported', wc.text())

        with WarningCollector() as wc:
            self.eq(Ceil(a), 'ceil(a)')
        self.assertIn('Unsupported', wc.text())

        with WarningCollector() as wc:
            self.eq(Floor(a), 'floor(a)')
        self.assertIn('Unsupported', wc.text())

    def test_conditional_operators(self):
        a, b, c, d = self.abcd

        self.eq(Equal(a, b), 'heaviside(a - b) * heaviside(b - a)')

        self.eq(Less(a, b), '(1 - heaviside(a - b))')

        self.eq(LessEqual(a, b), 'heaviside(b - a)')

        self.eq(More(a, b), '(1 - heaviside(b - a))')

        self.eq(MoreEqual(a, b), 'heaviside(a - b)')

        self.eq(NotEqual(a, b), '(1 - heaviside(a - b) * heaviside(b - a))')

        self.eq(Not(NotEqual(a, b)), 'heaviside(a - b) * heaviside(b - a)')

        self.eq(Not(Not(Equal(a, b))), 'heaviside(a - b) * heaviside(b - a)')

        self.eq(
            And(Equal(a, b), NotEqual(c, d)),
            'heaviside(a - b) * heaviside(b - a)'
            ' * (1 - heaviside(c - d) * heaviside(d - c))',
        )

        self.eq(
            Or(More(d, c), MoreEqual(b, a)),
            '(1 - heaviside(c - d) * (1 - heaviside(b - a)))',
        )

        self.eq(
            Or(Less(d, c), LessEqual(b, a)),
            '(1 - heaviside(d - c) * (1 - heaviside(a - b)))',
        )

        self.eq(
            Not(Or(Equal(Number(1), Number(2)), Equal(Number(3), Number(4)))),
            '(1 - heaviside(1.0 - 2.0) * heaviside(2.0 - 1.0))'
            ' * (1 - heaviside(3.0 - 4.0) * heaviside(4.0 - 3.0))',
        )

        self.eq(Not(Less(Number(1), Number(2))), 'heaviside(1.0 - 2.0)')

    def test_if_expressions(self):
        a, b, c, d = self.abcd

        self.eq(
            If(Equal(a, b), c, d),
            '(c * heaviside(a - b) * heaviside(b - a)'
            ' + d * (1 - heaviside(a - b) * heaviside(b - a)))',
        )

        self.eq(
            If(Equal(a, b), c, Number(0)),
            'c * heaviside(a - b) * heaviside(b - a)',
        )

        self.eq(
            If(Equal(a, b), Number(0), d),
            'd * (1 - heaviside(a - b) * heaviside(b - a))',
        )

        self.eq(
            If(Equal(a, b), c, Number(1)),
            '(c * heaviside(a - b) * heaviside(b - a)'
            ' + (1 - heaviside(a - b) * heaviside(b - a)))',
        )

        self.eq(
            If(Equal(a, b), Number(1), d),
            '(heaviside(a - b) * heaviside(b - a)'
            ' + d * (1 - heaviside(a - b) * heaviside(b - a)))'
        )

        self.eq(
            If(NotEqual(a, b), c, d),
            '(c * (1 - heaviside(a - b) * heaviside(b - a))'
            ' + d * heaviside(a - b) * heaviside(b - a))',
        )

        self.eq(
            If(More(a, b), c, d),
            '(c * (1 - heaviside(b - a)) + d * heaviside(b - a))',
        )

        self.eq(
            If(MoreEqual(a, b), c, d),
            '(c * heaviside(a - b) + d * (1 - heaviside(a - b)))',
        )

        self.eq(
            If(Less(a, b), c, d),
            '(c * (1 - heaviside(a - b)) + d * heaviside(a - b))',
        )

        self.eq(
            If(LessEqual(a, b), c, d),
            '(c * heaviside(b - a) + d * (1 - heaviside(b - a)))',
        )

    def test_piecewise_expressions(self):
        a, b, c, d = self.abcd

        self.eq(Piecewise(Equal(a, b), c, d), self.w.ex(If(Equal(a, b), c, d)))

        self.eq(
            Piecewise(NotEqual(a, b), c, d),
            self.w.ex(
                If(NotEqual(a, b), c, d),
            ),
        )

        self.eq(
            Piecewise(More(a, b), c, d),
            self.w.ex(
                If(More(a, b), c, d),
            ),
        )

        self.eq(
            Piecewise(MoreEqual(a, b), c, d),
            self.w.ex(If(MoreEqual(a, b), c, d)),
        )

        self.eq(Piecewise(Less(a, b), c, d), self.w.ex(If(Less(a, b), c, d)))

        self.eq(
            Piecewise(LessEqual(a, b), c, d),
            self.w.ex(
                If(LessEqual(a, b), c, d),
            ),
        )

        self.eq(
            Piecewise(Equal(a, b), c, Equal(a, d), Number(3), Number(4)),
            self.w.ex(
                If(Equal(a, b), c, If(Equal(a, d), Number(3), Number(4)))
            ),
        )

        self.eq(
            Piecewise(Less(a, b), Number(0), Less(c, d), Number(0), Number(5)),
            '5.0 * heaviside(c - d) * heaviside(a - b)',
        )

    def test_heaviside_numerical(self):
        """Test generated heaviside expressions with numerical values"""

        def heaviside(x):
            return 1 if x >= 0 else 0

        values = itertools.product(
            [-10e9, -1, -1e-9, 0, 1e-9, 1, 10e9], repeat=4
        )

        for a, b, c, d in values:
            # a == b
            result = int(a == b)
            expr = self.w.ex(Equal(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # a < b
            result = int(a < b)
            expr = self.w.ex(Less(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # a <= b
            result = int(a <= b)
            expr = self.w.ex(LessEqual(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # a > b
            result = int(a > b)
            expr = self.w.ex(More(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # a >= b
            result = int(a >= b)
            expr = self.w.ex(MoreEqual(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # a != b
            result = int(a != b)
            expr = self.w.ex(NotEqual(Number(a), Number(b)))
            self.assertEqual(eval(expr), result)

            # not(a != b)
            result = int(not (a != b))
            expr = self.w.ex(Not(NotEqual(Number(a), Number(b))))
            self.assertEqual(eval(expr), result)

            # not(not(a == b))
            result = int(not (not (a == b)))
            expr = self.w.ex(Not(Not(Equal(Number(a), Number(b)))))
            self.assertEqual(eval(expr), result)

            # (a == b) and (c != d)
            result = int((a == b) and (c != d))
            expr = self.w.ex(
                And(
                    Equal(Number(a), Number(b)), NotEqual(Number(c), Number(d))
                )
            )
            self.assertEqual(eval(expr), result)

            # (d > c) or (b >= a)
            result = int((d > c) or (b >= a))
            expr = self.w.ex(
                Or(More(Number(d), Number(c)), MoreEqual(Number(b), Number(a)))
            )
            self.assertEqual(eval(expr), result)

            # (d < c) or (b <= a)
            result = int((d < c) or (b <= a))
            expr = self.w.ex(
                Or(Less(Number(d), Number(c)), LessEqual(Number(b), Number(a)))
            )
            self.assertEqual(eval(expr), result)

            # (a == b) or (c == d)
            result = int((a == b) or (c == d))
            expr = self.w.ex(
                Or(Equal(Number(a), Number(b)), Equal(Number(c), Number(d)))
            )
            self.assertEqual(eval(expr), result)

            # not(a < b)
            result = int(not (a < b))
            expr = self.w.ex(Not(Less(Number(a), Number(b))))
            self.assertEqual(eval(expr), result)

            # if(a > b, c, d)
            result = c if (a > b) else d
            expr = self.w.ex(
                If(More(Number(a), Number(b)), Number(c), Number(d))
            )
            self.assertEqual(eval(expr), result)

            # if(a >= b, c, d)
            result = c if (a >= b) else d
            expr = self.w.ex(
                If(MoreEqual(Number(a), Number(b)), Number(c), Number(d))
            )
            self.assertEqual(eval(expr), result)

            # if(a < b, c, d)
            result = c if (a < b) else d
            expr = self.w.ex(
                If(Less(Number(a), Number(b)), Number(c), Number(d))
            )
            self.assertEqual(eval(expr), result)

            # if(a <= b, c, d)
            result = c if (a <= b) else d
            expr = self.w.ex(
                If(LessEqual(Number(a), Number(b)), Number(c), Number(d))
            )
            self.assertEqual(eval(expr), result)

            # piecewise(a > b, c, d)
            result = c if (a > b) else d
            expr = self.w.ex(
                Piecewise(More(Number(a), Number(b)), Number(c), Number(d))
            )
            self.assertEqual(eval(expr), result)

            # piecewise(a >= b, c, d)
            result = c if (a >= b) else d
            expr = self.w.ex(
                Piecewise(
                    MoreEqual(Number(a), Number(b)), Number(c), Number(d)
                )
            )
            self.assertEqual(eval(expr), result)

            # piecewise(a < b, c, d)
            result = c if (a < b) else d
            expr = self.w.ex(
                Piecewise(Less(Number(a), Number(b)), Number(c), Number(d))
            )
            self.assertEqual(eval(expr), result)

            # piecewise(a <= b, c, d)
            result = c if (a <= b) else d
            expr = self.w.ex(
                Piecewise(
                    LessEqual(Number(a), Number(b)), Number(c), Number(d)
                )
            )
            self.assertEqual(eval(expr), result)

            # piecewise(a == b, c, a == d, 3, 4)
            result = c if (a == b) else (3 if (a == d) else 4)
            expr = self.w.ex(
                Piecewise(
                    Equal(Number(a), Number(b)),
                    Number(c),
                    Equal(Number(a), Number(d)),
                    Number(3),
                    Number(4),
                )
            )
            self.assertEqual(eval(expr), result)

            # piecewise(a < b, 0, c < d, 0, 5)
            result = 0 if (a < b) else (0 if (c < d) else 5)
            expr = self.w.ex(
                Piecewise(
                    Less(Number(a), Number(b)),
                    Number(0),
                    Less(Number(c), Number(d)),
                    Number(0),
                    Number(5),
                ),
            )
            self.assertEqual(eval(expr), result)


if __name__ == '__main__':
    unittest.main()
